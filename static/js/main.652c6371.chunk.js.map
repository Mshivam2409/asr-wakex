{"version":3,"sources":["../../src/utils/inference.ts","../../src/vad.ts","../../src/asr.ts","App.tsx","index.tsx"],"names":["useVoiceActivityDetection","timeOut","useState","navigator","audio","stream","window","options","onVoiceStart","setVoiceState","onVoiceStop","onUpdate","setVolume","destroy","vad","audioContext","setTimeout","startUserMedia","_","setError","setErrormsg","e","voiceState","volume","error","COMMAND","constructor","commands","threshold","intialize","a","console","argMax","array","largest","largest_index","index","update","element","listen","_listen","result","word","Promise","resolve","reject","includeSpectrogram","probabilityThreshold","_threshold","stop","this","create","useOnlineAnswering","React","useSound","useCountDown","reset","extraCommands","command","callback","listening","setListening","stopRecording","commandRecognizer","isFuzzyMatch","fuzzyMatchingThreshold","recognizer","useSpeechRecognition","SpeechRecognition","continuous","name","permissionStatus","setMicPermission","useReactMediaRecorder","onStop","setAudioBlob","ready","setFinished","start","playBuzzin","startRecording","setAnswer","useEffect","timeLeft","status","playBuzzout","transcript","complete","permissions","ASR","Mic","micPermission","initialize","finished","startListening","startVoiceActivityDetection","stopListening","recordingState","answer","errormsg","setIsReady","state","setReady","App","buzzin","setBuzzin","finalanswer","src","setSrc","buzzout","onAudioData","timeout","onComplete","blob","URL","createObjectURL","log","onBuzzin","ASRthreshold","totalGameTime","className","onClick","then","controls","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.652c6371.chunk.js","sourcesContent":["import '@tensorflow/tfjs'\r\nimport '@tensorflow/tfjs-backend-webgl'\r\nimport {\r\n  SpeechCommandRecognizer,\r\n  create\r\n} from '@tensorflow-models/speech-commands'\r\n\r\nexport enum COMMAND {\r\n  BUZZIN_COMMAND = 'go',\r\n  BUZZOUT_COMMAND = 'stop'\r\n}\r\n\r\nexport interface speechCommand {\r\n  command: COMMAND\r\n  callback: () => void\r\n}\r\n\r\nclass ASREngine {\r\n  _recognizer: SpeechCommandRecognizer\r\n  _init: boolean\r\n  _buzzedin: boolean\r\n  _commands: { [key: string]: speechCommand['callback'] }\r\n  _last_command: string\r\n  _threshold: number\r\n  constructor(commands?: Array<speechCommand>, threshold?: number) {\r\n    this._recognizer = create('BROWSER_FFT')\r\n    this._init = false\r\n    this._commands = {}\r\n    ;(commands || []).forEach((element) => {\r\n      this._commands[element.command] = element.callback\r\n    })\r\n    this._last_command = ''\r\n    this._threshold = threshold || 0.9\r\n    this._buzzedin = false\r\n  }\r\n\r\n  intialize = async () => {\r\n    await this._recognizer.ensureModelLoaded()\r\n    console.log(this._recognizer.wordLabels())\r\n    this._init = true\r\n  }\r\n\r\n  argMax = (array: Float32Array) => {\r\n    var largest = 0\r\n    var largest_index = -1\r\n    for (let index = 0; index < array.length; index++) {\r\n      if (array[index] > largest) {\r\n        largest = array[index]\r\n        largest_index = index\r\n      }\r\n    }\r\n    return largest_index\r\n  }\r\n\r\n  update = (commands: Array<speechCommand>) => {\r\n    commands.forEach((element) => {\r\n      this._commands[element.command] = element.callback\r\n    })\r\n  }\r\n\r\n  listen = () => {\r\n    if (this._recognizer.isListening()) {\r\n      this._recognizer.stopListening().then(() => {\r\n        this._listen()\r\n      })\r\n    } else {\r\n      this._listen()\r\n    }\r\n  }\r\n\r\n  _listen = () => {\r\n    this._recognizer.listen(\r\n      (result) => {\r\n        const word = this._recognizer.wordLabels()[\r\n          this.argMax(result.scores as Float32Array)\r\n        ] as COMMAND\r\n\r\n        if (word == COMMAND.BUZZIN_COMMAND && this._buzzedin) {\r\n          return Promise.resolve()\r\n        } else if (word == COMMAND.BUZZOUT_COMMAND && !this._buzzedin) {\r\n          return Promise.resolve()\r\n        } else if (word == COMMAND.BUZZIN_COMMAND && !this._buzzedin) {\r\n          this._buzzedin = true\r\n        } else if (word == COMMAND.BUZZOUT_COMMAND && !this._buzzedin) {\r\n          this._buzzedin = false\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n          if (this._last_command != word) {\r\n            this._last_command = word\r\n            try {\r\n              if (word in this._commands) {\r\n                this._commands[word]()\r\n                resolve()\r\n              }\r\n            } catch (error) {\r\n              reject()\r\n            }\r\n          }\r\n          resolve()\r\n        })\r\n      },\r\n      {\r\n        includeSpectrogram: true,\r\n        probabilityThreshold: this._threshold\r\n      }\r\n    )\r\n  }\r\n\r\n  stop = () => {\r\n    if (this._recognizer.isListening()) this._recognizer.stopListening()\r\n  }\r\n}\r\n\r\nexport default ASREngine\r\n","import { useState } from 'react';\r\nimport vad, { VoiceActivityDetectionOptions } from 'voice-activity-detection';\r\n\r\nconst useVoiceActivityDetection = (timeOut: number): [() => void, boolean, number, boolean, string] => {\r\n\r\n    const [volume, setVolume] = useState<number>(0)\r\n    const [voiceState, setVoiceState] = useState<boolean>(false)\r\n    const [error, setError] = useState<boolean>(false)\r\n    const [errormsg, setErrormsg] = useState<string>(\"\")\r\n\r\n    const startVoiceActivityDetection = () => {\r\n        try {\r\n            navigator.mediaDevices.getUserMedia({ audio: true }).then((stream) => {\r\n                window.AudioContext = window.AudioContext || (window as any).webkitAudioContext;\r\n                var audioContext = new AudioContext();\r\n                startUserMedia(audioContext, stream)\r\n            }).catch((_) => handleMicConnectError())\r\n        } catch (e) {\r\n            handleUserMediaError();\r\n        }\r\n    }\r\n\r\n\r\n    function handleUserMediaError() {\r\n        setError(true)\r\n        setErrormsg('Mic input is not supported by the browser.');\r\n    }\r\n\r\n    function handleMicConnectError() {\r\n        setError(true)\r\n        setErrormsg('Could not connect microphone. Possible rejected by the user or is blocked by the browser.');\r\n    }\r\n\r\n    function startUserMedia(audioContext: AudioContext, stream: MediaStream) {\r\n        var options: VoiceActivityDetectionOptions = {\r\n            onVoiceStart: function () {\r\n                setVoiceState(true)\r\n            },\r\n            onVoiceStop: function () {\r\n                setVoiceState(false)\r\n            },\r\n            onUpdate: function (val) {\r\n                setVolume(val)\r\n            }\r\n        };\r\n        const { destroy } = vad(audioContext, stream, options);\r\n        setTimeout(() => {\r\n            destroy()\r\n        }, timeOut)\r\n    }\r\n\r\n\r\n    return [startVoiceActivityDetection, voiceState, volume, error, errormsg];\r\n}\r\n\r\nexport default useVoiceActivityDetection","import * as React from 'react'\r\nimport { useEffect } from 'react'\r\nimport SpeechRecognition, {\r\n  SpeechRecognitionOptions,\r\n  useSpeechRecognition\r\n} from 'react-speech-recognition'\r\nimport useSound from 'use-sound'\r\nimport { useReactMediaRecorder } from 'react-media-recorder'\r\nimport useCountDown from 'react-countdown-hook'\r\nimport ASREngine, { COMMAND } from './utils/inference'\r\nimport useVoiceActivityDetection from './vad'\r\n\r\nexport interface opts {\r\n  audio: {\r\n    buzzin: string\r\n    buzzout: string\r\n  }\r\n  timeout: number\r\n  onAudioData: (data: Array<number>, ...params: Array<any>) => void\r\n  onBuzzin: (...params: Array<any>) => void\r\n  onComplete: (answer: string, audioBlob: Blob, ...params: Array<any>) => void\r\n  totalGameTime: number\r\n  ASRthreshold?: number\r\n}\r\n\r\nconst useOnlineAnswering = (options: opts) => {\r\n  const [answer, setAnswer] = React.useState<Array<string>>([])\r\n  const [listening, setListening] = React.useState<boolean>(false)\r\n  const [audioBlob, setAudioBlob] = React.useState<Blob>()\r\n  const [finished, setFinished] = React.useState<boolean>(true)\r\n  const [playBuzzin] = useSound(options.audio.buzzin)\r\n  const [playBuzzout] = useSound(options.audio.buzzout)\r\n  const [ready, setReady] = React.useState<boolean>(false)\r\n  const [micPermission, setMicPermission] = React.useState<\r\n    'granted' | 'denied' | 'prompt' | 'unknown'\r\n  >('unknown')\r\n  const [timeLeft, { start, reset }] = useCountDown(options.timeout, 100)\r\n  const [startVoiceActivityDetection, voiceState, volume, error, errormsg] =\r\n    useVoiceActivityDetection(options.totalGameTime)\r\n\r\n  const extraCommands: SpeechRecognitionOptions['commands'] = [\r\n    {\r\n      command: 'Stop',\r\n      callback: (_) => {\r\n        if (listening && !finished) {\r\n          console.log('[ASR] : Stopped')\r\n          setListening(false)\r\n          stopRecording()\r\n          commandRecognizer._buzzedin = false\r\n        }\r\n      },\r\n      isFuzzyMatch: true,\r\n      fuzzyMatchingThreshold: 0.2\r\n    }\r\n  ]\r\n\r\n  const recognizer = useSpeechRecognition({ commands: extraCommands })\r\n\r\n  SpeechRecognition.startListening({ continuous: true })\r\n\r\n  try {\r\n    ;(navigator as any).permissions\r\n      .query({ name: 'microphone' })\r\n      .then(function (permissionStatus: any) {\r\n        setMicPermission(permissionStatus.state)\r\n      })\r\n  } catch (error) {\r\n    console.log('error')\r\n  }\r\n\r\n  const { status, startRecording, stopRecording } = useReactMediaRecorder({\r\n    audio: true,\r\n    onStop: (_: string, blob: Blob) => {\r\n      setAudioBlob(blob)\r\n    }\r\n  })\r\n\r\n  const complete = () => {\r\n    if (recognizer.finalTranscript.length >= 0 && audioBlob) {\r\n      playBuzzout()\r\n      var transcript = recognizer.finalTranscript\r\n      SpeechRecognition.stopListening()\r\n      options.onComplete(\r\n        transcript\r\n          .split(' ')\r\n          .slice(0, -1)\r\n          .join(' ')\r\n          .toLowerCase()\r\n          .replace('go'.toLowerCase(), '')\r\n          .replace('stop'.toLowerCase(), '')\r\n          .replace(/[^\\w\\s]|_/g, ''),\r\n        audioBlob\r\n      )\r\n    }\r\n    if (audioBlob) setFinished(false)\r\n  }\r\n\r\n  const commands = [\r\n    {\r\n      command: COMMAND.BUZZIN_COMMAND,\r\n      callback: () => {\r\n        console.log(`[ASR] : Ready: ${ready}, Finished: ${finished}`)\r\n        if (ready && finished && !listening) {\r\n          setFinished(false)\r\n          recognizer.resetTranscript()\r\n          reset()\r\n          start()\r\n          console.log('[SR] Buzzed In')\r\n          options.onBuzzin()\r\n          playBuzzin()\r\n          startRecording()\r\n          setAnswer([])\r\n          setListening(true)\r\n        }\r\n      }\r\n    },\r\n    {\r\n      command: COMMAND.BUZZOUT_COMMAND,\r\n      callback: () => {\r\n        if (listening && !finished) {\r\n          console.log('[ASR] : Stopped')\r\n          setListening(false)\r\n          stopRecording()\r\n        }\r\n      }\r\n    }\r\n  ]\r\n  const commandRecognizer = new ASREngine(commands, options.ASRthreshold)\r\n\r\n  useEffect(() => {\r\n    if (timeLeft === 100) {\r\n      console.log(listening, finished)\r\n      if (listening && !finished) {\r\n        stopRecording()\r\n      }\r\n    }\r\n  }, [timeLeft])\r\n\r\n  useEffect(() => {\r\n    if (status == 'stopped') {\r\n      console.log('[ASR] Blob Ready')\r\n      complete()\r\n    }\r\n  }, [audioBlob])\r\n\r\n  const permissions = {\r\n    ASR: SpeechRecognition.browserSupportsSpeechRecognition(),\r\n    Mic: micPermission\r\n  }\r\n\r\n  const initialize = async () => {\r\n    await commandRecognizer.intialize()\r\n  }\r\n\r\n  const startListening = () => {\r\n    commandRecognizer.listen()\r\n    startVoiceActivityDetection()\r\n  }\r\n\r\n  const stopListening = () => {\r\n    commandRecognizer.stop()\r\n  }\r\n\r\n  const setIsReady = (state: boolean) => {\r\n    console.log(state)\r\n    setReady(state)\r\n  }\r\n\r\n  useEffect(() => {\r\n    console.log('[ASR] State changed to ', ready, '! Updating Commands')\r\n    commandRecognizer.update(commands)\r\n    commandRecognizer.stop()\r\n    commandRecognizer.listen()\r\n    console.log('[ASR] Updated Commands')\r\n  }, [ready, finished, listening])\r\n\r\n  const data = {\r\n    initialize,\r\n    startListening,\r\n    stopListening,\r\n    listening,\r\n    recordingState: status,\r\n    timeLeft,\r\n    voiceState,\r\n    volume,\r\n    answer,\r\n    permissions,\r\n    error,\r\n    errormsg,\r\n    ready,\r\n    setIsReady\r\n  }\r\n\r\n  return data\r\n}\r\n\r\nexport default useOnlineAnswering\r\n","import React, { useState } from 'react'\n\nimport { useOnlineAnswering } from 'asr-answering'\n\nconst App = () => {\n  // const [ready, setReady] = useState(false)\n  const [buzzin, setBuzzin] = useState(false)\n  const [finalanswer, setAnswer] = useState('')\n  const [src, setSrc] = useState('')\n  const {\n    initialize,\n    startListening,\n    stopListening,\n    // listening,\n    // recordingState,\n    // timeLeft,\n    voiceState,\n    volume,\n    // answer,\n    permissions,\n    // error,\n    // errormsg,\n    setIsReady,\n    ready\n  } = useOnlineAnswering({\n    audio: {\n      buzzin:\n        'https://assets.mixkit.co/sfx/download/mixkit-game-show-wrong-answer-buzz-950.wav',\n      buzzout:\n        'https://assets.mixkit.co/sfx/download/mixkit-game-show-wrong-answer-buzz-950.wav'\n    },\n    onAudioData: () => {},\n    timeout: 10000,\n    onComplete: async (answer, blob) => {\n      setAnswer(answer)\n      setBuzzin(false)\n      setSrc(URL.createObjectURL(blob))\n      console.log(answer, blob)\n    },\n    onBuzzin: () => {\n      setBuzzin(true)\n      console.log('Buzzed In')\n    },\n    ASRthreshold: 0.8,\n    totalGameTime: 300\n  })\n\n  return (\n    <div className='App'>\n      <header className='App-header'>\n        <p>{`ASR is ${ready ? 'ready' : 'not ready'} to use.`}</p>\n        <p>\n          Press Enable to enable ASR. <br /> Press listen to start listening,\n          speak go, then you will buzz in, speak your answer, then speak stop.\n          <br />\n          You must wait around 3-4s after saying stop to allow time for\n          processing.\n          <br /> Press stop to turn off ASR.\n          <br />\n          You can listen to recorded audio after processing ends.\n        </p>\n        <p>{`Mic permission is ${permissions.Mic}`}</p>\n        <p>{`Browser Supports ASR : ${permissions.ASR}`}</p>\n        <p>{`Volume is ${volume}`}</p>\n        <p>{`Speaking :  ${voiceState}`}</p>\n\n        <button\n          onClick={async () => {\n            setIsReady(true)\n\n            initialize().then(() => {\n              startListening()\n              console.log('Ready to listen!')\n            })\n          }}\n        >\n          ENABLE\n        </button>\n        <button\n          onClick={() => {\n            startListening()\n          }}\n        >\n          LISTEN\n        </button>\n        <button\n          onClick={() => {\n            stopListening()\n          }}\n        >\n          STOP\n        </button>\n\n        <p>{` ${buzzin ? 'Buzzed In' : 'Not Buzzed In'}.`}</p>\n        <p>{`Answer is ${finalanswer}.`}</p>\n        {src !== '' && <audio controls src={src} />}\n      </header>\n    </div>\n  )\n}\n\nexport default App\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}